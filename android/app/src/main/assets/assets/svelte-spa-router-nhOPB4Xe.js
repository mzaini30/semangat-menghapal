import{T as A,U as K,S as M,i as V,s as Z,e as R,a as D,y as P,b,z as C,t as w,d as I,P as B,V as G,W as Q,X as x,Y as $,w as U,Z as v,H as E,I as j,K as S,q as O,J as q,g as W}from"./svelte-QizFD8P7.js";import{p as ee}from"./regexparam-Ai9HIJYQ.js";function te(r){let e,n,c;const u=[r[2]];var f=r[0];function _(s,t){let o={};if(t!==void 0&&t&4)o=O(u,[q(s[2])]);else for(let p=0;p<u.length;p+=1)o=W(o,u[p]);return{props:o}}return f&&(e=v(f,_(r)),e.$on("routeEvent",r[7])),{c(){e&&E(e.$$.fragment),n=R()},m(s,t){e&&j(e,s,t),D(s,n,t),c=!0},p(s,t){if(t&1&&f!==(f=s[0])){if(e){P();const o=e;b(o.$$.fragment,1,0,()=>{S(o,1)}),C()}f?(e=v(f,_(s,t)),e.$on("routeEvent",s[7]),E(e.$$.fragment),w(e.$$.fragment,1),j(e,n.parentNode,n)):e=null}else if(f){const o=t&4?O(u,[q(s[2])]):{};e.$set(o)}},i(s){c||(e&&w(e.$$.fragment,s),c=!0)},o(s){e&&b(e.$$.fragment,s),c=!1},d(s){s&&I(n),e&&S(e,s)}}}function se(r){let e,n,c;const u=[{params:r[1]},r[2]];var f=r[0];function _(s,t){let o={};if(t!==void 0&&t&6)o=O(u,[t&2&&{params:s[1]},t&4&&q(s[2])]);else for(let p=0;p<u.length;p+=1)o=W(o,u[p]);return{props:o}}return f&&(e=v(f,_(r)),e.$on("routeEvent",r[6])),{c(){e&&E(e.$$.fragment),n=R()},m(s,t){e&&j(e,s,t),D(s,n,t),c=!0},p(s,t){if(t&1&&f!==(f=s[0])){if(e){P();const o=e;b(o.$$.fragment,1,0,()=>{S(o,1)}),C()}f?(e=v(f,_(s,t)),e.$on("routeEvent",s[6]),E(e.$$.fragment),w(e.$$.fragment,1),j(e,n.parentNode,n)):e=null}else if(f){const o=t&6?O(u,[t&2&&{params:s[1]},t&4&&q(s[2])]):{};e.$set(o)}},i(s){c||(e&&w(e.$$.fragment,s),c=!0)},o(s){e&&b(e.$$.fragment,s),c=!1},d(s){s&&I(n),e&&S(e,s)}}}function ne(r){let e,n,c,u;const f=[se,te],_=[];function s(t,o){return t[1]?0:1}return e=s(r),n=_[e]=f[e](r),{c(){n.c(),c=R()},m(t,o){_[e].m(t,o),D(t,c,o),u=!0},p(t,[o]){let p=e;e=s(t),e===p?_[e].p(t,o):(P(),b(_[p],1,1,()=>{_[p]=null}),C(),n=_[e],n?n.p(t,o):(n=_[e]=f[e](t),n.c()),w(n,1),n.m(c.parentNode,c))},i(t){u||(w(n),u=!0)},o(t){b(n),u=!1},d(t){t&&I(c),_[e].d(t)}}}function X(){const r=window.location.href.indexOf("#/");let e=r>-1?window.location.href.substr(r+1):"/";const n=e.indexOf("?");let c="";return n>-1&&(c=e.substr(n+1),e=e.substr(0,n)),{location:e,querystring:c}}const N=K(null,function(e){e(X());const n=()=>{e(X())};return window.addEventListener("hashchange",n,!1),function(){window.removeEventListener("hashchange",n,!1)}});A(N,r=>r.location);A(N,r=>r.querystring);const Y=x(void 0);function oe(r){r?window.scrollTo(r.__svelte_spa_router_scrollX,r.__svelte_spa_router_scrollY):window.scrollTo(0,0)}function re(r,e,n){let{routes:c={}}=e,{prefix:u=""}=e,{restoreScrollState:f=!1}=e;class _{constructor(i,a){if(!a||typeof a!="function"&&(typeof a!="object"||a._sveltesparouter!==!0))throw Error("Invalid component object");if(!i||typeof i=="string"&&(i.length<1||i.charAt(0)!="/"&&i.charAt(0)!="*")||typeof i=="object"&&!(i instanceof RegExp))throw Error('Invalid value for "path" argument - strings must start with / or *');const{pattern:m,keys:h}=ee(i);this.path=i,typeof a=="object"&&a._sveltesparouter===!0?(this.component=a.component,this.conditions=a.conditions||[],this.userData=a.userData,this.props=a.props||{}):(this.component=()=>Promise.resolve(a),this.conditions=[],this.props={}),this._pattern=m,this._keys=h}match(i){if(u){if(typeof u=="string")if(i.startsWith(u))i=i.substr(u.length)||"/";else return null;else if(u instanceof RegExp){const d=i.match(u);if(d&&d[0])i=i.substr(d[0].length)||"/";else return null}}const a=this._pattern.exec(i);if(a===null)return null;if(this._keys===!1)return a;const m={};let h=0;for(;h<this._keys.length;){try{m[this._keys[h]]=decodeURIComponent(a[h+1]||"")||null}catch(d){m[this._keys[h]]=null}h++}return m}async checkConditions(i){for(let a=0;a<this.conditions.length;a++)if(!await this.conditions[a](i))return!1;return!0}}const s=[];c instanceof Map?c.forEach((l,i)=>{s.push(new _(i,l))}):Object.keys(c).forEach(l=>{s.push(new _(l,c[l]))});let t=null,o=null,p={};const z=B();async function k(l,i){await $(),z(l,i)}let L=null,y=null;f&&(y=l=>{l.state&&(l.state.__svelte_spa_router_scrollY||l.state.__svelte_spa_router_scrollX)?L=l.state:L=null},window.addEventListener("popstate",y),G(()=>{oe(L)}));let T=null,g=null;const F=N.subscribe(async l=>{T=l;let i=0;for(;i<s.length;){const a=s[i].match(l.location);if(!a){i++;continue}const m={route:s[i].path,location:l.location,querystring:l.querystring,userData:s[i].userData,params:a&&typeof a=="object"&&Object.keys(a).length?a:null};if(!await s[i].checkConditions(m)){n(0,t=null),g=null,k("conditionsFailed",m);return}k("routeLoading",Object.assign({},m));const h=s[i].component;if(g!=h){h.loading?(n(0,t=h.loading),g=h,n(1,o=h.loadingParams),n(2,p={}),k("routeLoaded",Object.assign({},m,{component:t,name:t.name,params:o}))):(n(0,t=null),g=null);const d=await h();if(l!=T)return;n(0,t=d&&d.default||d),g=h}a&&typeof a=="object"&&Object.keys(a).length?n(1,o=a):n(1,o=null),n(2,p=s[i].props),k("routeLoaded",Object.assign({},m,{component:t,name:t.name,params:o})).then(()=>{Y.set(o)});return}n(0,t=null),g=null,Y.set(void 0)});Q(()=>{F(),y&&window.removeEventListener("popstate",y)});function H(l){U.call(this,r,l)}function J(l){U.call(this,r,l)}return r.$$set=l=>{"routes"in l&&n(3,c=l.routes),"prefix"in l&&n(4,u=l.prefix),"restoreScrollState"in l&&n(5,f=l.restoreScrollState)},r.$$.update=()=>{r.$$.dirty&32&&(history.scrollRestoration=f?"manual":"auto")},[t,o,p,c,u,f,H,J]}class ae extends M{constructor(e){super(),V(this,e,re,ne,Z,{routes:3,prefix:4,restoreScrollState:5})}}export{ae as R};
